// Copyright (C) 2018 Thejaka Amila Kanewala, Marcin Zalewski, Andrew Lumsdaine.

// Boost Software License - Version 1.0 - August 17th, 2003

// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:

// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//  Authors: Thejaka Kanewala
//           Andrew Lumsdaine

#ifndef BOOST_GRAPH_THREAD_PRIORITY_Q_DEF
#define BOOST_GRAPH_THREAD_PRIORITY_Q_DEF

#include <queue>

namespace boost {
namespace graph {
namespace distributed {

//==================== The default thread priority queue ==========================
template<typename vertex_distance, typename Compare>
struct thread_priority_queue {

  typedef std::priority_queue<vertex_distance, std::vector<vertex_distance>, Compare> DefaultPriorityQueueType;
  
  thread_priority_queue(const thread_priority_queue& npq) {
  }

  thread_priority_queue(int threads) {
    thread_pqs.resize(threads);
    for(int i=0; i < threads; ++i) {
      thread_pqs[i] = new DefaultPriorityQueueType();
    }
  }

  ~thread_priority_queue() {
    typename std::vector<DefaultPriorityQueueType*>::iterator 
      ite = thread_pqs.begin();
    for(; ite != thread_pqs.end(); ++ite) {
      delete (*ite);
    }
  }

  void initialize(int _tid, bool ignore) {}

  void allocate_pqs() {}

  void put(const vertex_distance& p, int tid) {
    thread_pqs[tid]->push(p);
  }

  bool pop(vertex_distance& p, int tid) {
    if (thread_pqs[tid]->empty())
      return false;

    p = thread_pqs[tid]->top();
    thread_pqs[tid]->pop();
    return true;
  }

  vertex_distance top(int tid) {
    assert(false);
  }

  size_t size(int tid) const {
    return thread_pqs[tid]->size();
  }

  size_t size() const {
    //TODO 
    assert(false);
  }

  void clear(int tid) {
    assert(thread_pqs[tid]->empty());
  }

  void clear() {
    // TODO
    assert(false);
  }

  bool empty(int tid) {
    return thread_pqs[tid]->empty();
  }

  bool empty() {
    // this call is not thread safe
    bool emp = true;
    for (int i=0; i<thread_pqs.size(); ++i) {
      emp = emp && empty(i);
    }
    return emp;
  }

private:
  std::vector<DefaultPriorityQueueType*> thread_pqs;
};

// Thread priority queue generator
struct thread_priority_queue_gen {
  template<typename vertex_distance, typename Compare>
  struct queue {
    typedef thread_priority_queue<vertex_distance, Compare> type;
  };
};

}
}
}
#endif
