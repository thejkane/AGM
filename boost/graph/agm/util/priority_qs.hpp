// Copyright (C) 2018 Thejaka Amila Kanewala, Marcin Zalewski, Andrew Lumsdaine.

// Boost Software License - Version 1.0 - August 17th, 2003

// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:

// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//  Authors: Thejaka Kanewala
//           Andrew Lumsdaine

#ifndef __AGM_PRIORITY_Q_H__
#define __AGM_PRIORITY_Q_H__

// LibCDS stuff
//#include <cds/init.h>       // for cds::Initialize and cds::Terminate
//#include <cds/gc/hp.h>      // for cds::HP (Hazard Pointer) SMR
#include <cds/container/fcpriority_queue.h>

namespace boost { namespace graph { namespace agm {
      
template<typename work_item, typename Compare>
struct concurrent_priority_queue {

  typedef std::priority_queue<work_item, std::vector<work_item>, Compare> DefaultPriorityQueueType;
  typedef cds::container::FCPriorityQueue<work_item, DefaultPriorityQueueType> NodePriorityQueueType;

  concurrent_priority_queue(const concurrent_priority_queue& npq) {
  }

  // capacity ignored
  concurrent_priority_queue(int threads, unsigned long cap=0) {
    // Initialize Hazard Pointer singleton
    // cds::gc::HP hpGC;

    // Attach thread
    //    cds::threading::Manager::attachThread();
  }

  void put(const work_item& p, int tid) {
    node_pq.push(p);
  }

  bool pop(work_item& p, int tid) {
    return node_pq.pop(p);
  }

  size_t size(int tid) const {
    return node_pq.size();
  }

  size_t size() const {
    return size(0); // tid doesnt matter
  }

  void clear() {
    node_pq.clear();
  }

  bool empty(int tid) {
    return node_pq.empty();
  }

  bool empty() {
    return empty(0);
  }


private:
  NodePriorityQueueType node_pq;
};

}}}      
#endif
