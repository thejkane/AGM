// Copyright (C) 2018 Thejaka Amila Kanewala, Marcin Zalewski, Andrew Lumsdaine.

// Boost Software License - Version 1.0 - August 17th, 2003

// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:

// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//  Authors: Thejaka Kanewala
//           Andrew Lumsdaine

#ifndef __AGM_BFS_HPP
#define __AGM_BFS_HPP

#include <boost/config.hpp>
#include <boost/graph/graph_traits.hpp>
#include <boost/graph/iteration_macros.hpp>
#include <boost/graph/iteration_macros.hpp>

#include <boost/graph/agm/util/stat.hpp>
#include <boost/graph/agm/model/agm.hpp>
#include <boost/graph/agm/runtime/runtime.hpp>
#include <boost/graph/agm/model/general_orderings.hpp>

namespace boost { namespace graph { namespace agm {
      
// definition of the BFS work item set
typedef int Level;

template<typename Graph>
class bfs_family {

  typedef typename boost::graph_traits < Graph >::vertex_descriptor Vertex;

  // work item set definition
  // Every work item must have the time
  // destination, level
  typedef std::tuple<Vertex, Level> WorkItem;

  //===================================================================================
  // Pair of processing functions : post order pf and pre-order pf
  //===================================================================================
  // the post-order processing function  
  template<typename State>
  struct post_order_bfs_pf {
  public:
    post_order_bfs_pf(const Graph& _rg, State& _st, agm_work_stats& _sr) : g(_rg),
						       vlevel(_st),
						       stats(_sr){}
  private:
    const Graph& g;
    State& vlevel;
    agm_work_stats& stats;

  public:

    template<typename buckets>
    void operator()(const WorkItem& wi,
                    int tid,
		    buckets& outset) {
      
      Vertex v = std::get<0>(wi);
      int level = std::get<1>(wi);

      if (level == vlevel[v]) {
        BGL_FORALL_OUTEDGES_T(v, e, g, Graph) {
          Vertex u = boost::target(e, g);
#ifdef PBGL2_PRINT_WORK_STATS
          stats.increment_edges(tid);
#endif                    
          WorkItem generated(u, (level+1));
          outset.push(generated, tid);
        }        
      }
#ifdef PBGL2_PRINT_WORK_STATS
      else {
        stats.increment_invalidated_cancels(tid);
      }
#endif                      
    }
  };
      

  template<typename State>
  struct preorder_bfs_pf {
    
  public:
    preorder_bfs_pf(const Graph& _rg,
                    State& _st,
                    agm_work_stats& _sr) : g(_rg),
                                           vlevel(_st),
                                           stats(_sr){}
  private:
    const Graph& g;
    State& vlevel;
    agm_work_stats& stats;

  public:

    template<typename buckets>
    void operator()(const WorkItem& wi,
                    int tid,
		    buckets& outset) {
      
      Vertex v = std::get<0>(wi);
      int level = std::get<1>(wi);
      int old_level = vlevel[v], last_old_level;

      while(level < old_level) {
        last_old_level = old_level;
        old_level = boost::parallel::val_compare_and_swap(&vlevel[v], old_level, level);

        if (last_old_level == old_level) {
          
#ifdef PBGL2_PRINT_WORK_STATS        
          if (old_level < INT_MAX) {
            stats.increment_invalidated(tid);
          } else
            stats.increment_useful(tid);            
#endif
          outset.push(wi, tid);          
          return;
        }
      }
      
#ifdef PBGL2_PRINT_WORK_STATS                
      stats.increment_rejected(tid);
#endif      
    }
  };

  
  
  // the processing function  
  template<typename State>
  struct bfs_pf {

  public:
    bfs_pf(const Graph& _rg, State& _st, agm_work_stats& _sr) : g(_rg),
						       vlevel(_st),
						       stats(_sr){}
  private:
    const Graph& g;
    State& vlevel;
    agm_work_stats& stats;

  public:

    template<typename buckets>
    void operator()(const WorkItem& wi,
                    int tid,
		    buckets& outset) {
      
      Vertex v = std::get<0>(wi);
      int level = std::get<1>(wi);
      int old_level = vlevel[v], last_old_level;

      while(level < old_level) {
        last_old_level = old_level;
        old_level = boost::parallel::val_compare_and_swap(&vlevel[v], old_level, level);

        if (last_old_level == old_level) {
          
#ifdef PBGL2_PRINT_WORK_STATS        
          if (old_level < INT_MAX) {
            stats.increment_invalidated(tid);
          } else
            stats.increment_useful(tid);            

#endif
          BGL_FORALL_OUTEDGES_T(v, e, g, Graph) {
            Vertex u = boost::target(e, g);
#ifdef PBGL2_PRINT_WORK_STATS
          stats.increment_edges(tid);
#endif                      
            WorkItem generated(u, (level+1));
            outset.push(generated, tid);
          }

          return;
        }
      }
      
#ifdef PBGL2_PRINT_WORK_STATS                
      stats.increment_rejected(tid);
#endif      
    }
  };


public:
  template<typename DistMap>
  bool verify(const Graph& g, Vertex s, DistMap& dists) {


    dists.set_consistency_model(boost::parallel::cm_forward);
    dists.set_max_ghost_cells(0);

    if (g.transport().rank() == 0)
      info("Verifying distances ....");      

    {
      amplusplus::scoped_epoch epoch(g.transport());
	  
      BGL_FORALL_VERTICES_T(v, g, Graph) {
	BGL_FORALL_OUTEDGES_T(v, e, g, Graph) {
          boost::get(dists, target(e, g));
	}
      }
    }

    
    BGL_FORALL_VERTICES_T(v, g, Graph) {
      BGL_FORALL_OUTEDGES_T(v, e, g, Graph) {
	if (dists[source(e, g)] == INT_MAX) {
	  if (dists[target(e, g)] != INT_MAX) {
	    std::cout << "[ERROR] Source unvisited, therefore target must also be unvisited. But Target -- (" << target(e, g) << ", " << dists[target(e, g)] << ") -> Source -- ("
		      << source(e, g) << ", " << dists[source(e, g)] << ") " << std::endl;
	    std::abort();
	  }
	} else if (dists[target(e, g)] > (dists[source(e, g)] + 1)) {
	  std::cout << "[ERROR] Target distance is greater than source distance + 1: Target -- (" << target(e, g) << ", " << dists[target(e, g)] << ") -> Source -- ("
		    << source(e, g) << ", " << dists[source(e, g)] << ") " << std::endl;	  
	  std::abort();
	}
      }
    }

    info("Verification successful ...");
    return true;
  }


private:  
  template<typename RuntimeModelGen,
           typename EAGMConfig,
           typename LevelState>
  time_type execute_split_pf(const Graph& g,
                             RuntimeModelGen rtmodelgen,
                             EAGMConfig& config,
                             WorkItem sw,
                             LevelState vlevel,
                             instance_params& runtime_params,
                             agm_work_stats& sr, 
                             bool _verify=true) {
    // Initial work item set
    typedef append_buffer<WorkItem, 10u> InitialWorkItems;
    InitialWorkItems initial;
    auto s = std::get<0>(sw);
    if (get(get(vertex_owner, g), s) == _RANK) {      
      vlevel[s] = 0;
      initial.push_back(sw);
      
#ifdef PBGL2_PRINT_WORK_STATS        
      sr.increment_useful(0);            
#endif      
    }

    typedef preorder_bfs_pf<LevelState> ProcessingFunction;
    ProcessingFunction pf(g, vlevel, sr);

    typedef post_order_bfs_pf<LevelState> PostOrderProcessingFunction;
    PostOrderProcessingFunction sendpf(g, vlevel, sr);

    // BFS algorithm
    typedef eagm<Graph,
                 WorkItem,
                 ProcessingFunction,
                 EAGMConfig,
                 RuntimeModelGen,
                 PostOrderProcessingFunction> bfs_eagm_t;

    bfs_eagm_t bfsalgo(rtmodelgen,
                       config,
                       pf,
                       sendpf,
                       initial);
    
    info("Invoking BFS algorithm with split processing functions ...");
    time_type elapsed = bfsalgo(runtime_params);

#ifdef PBGL2_PRINT_WORK_STATS
    bfsalgo.print_stats();
#endif    
    
    return elapsed;            
  }  


  template<typename RuntimeModelGen,
           typename EAGMConfig,
           typename LevelState>
  time_type execute_pre_order_pf(const Graph& g,
                                 RuntimeModelGen rtmodelgen,
                                 EAGMConfig& config,
                                 WorkItem sw,
                                 LevelState vlevel,
                                 instance_params& runtime_params,
                                 agm_work_stats& sr, 
                                 bool _verify=true) {
    // Initial work item set
    typedef append_buffer<WorkItem, 10u> InitialWorkItems;
    InitialWorkItems initial;
    auto s = std::get<0>(sw);
    if (get(get(vertex_owner, g), s) == _RANK) {      
      initial.push_back(sw);
    }

    typedef bfs_pf<LevelState> ProcessingFunction;
    ProcessingFunction pf(g, vlevel, sr);

    // BFS algorithm
    typedef eagm<Graph,
                 WorkItem,
                 ProcessingFunction,
                 EAGMConfig,
                 RuntimeModelGen,
                 EMPTY_PF> bfs_eagm_t;

    bfs_eagm_t bfsalgo(rtmodelgen,
                       config,
                       pf,
                       initial);
    
    info("Invoking BFS algorithm with pre-order processing function ...");
    time_type elapsed = bfsalgo(runtime_params);

#ifdef PBGL2_PRINT_WORK_STATS
    bfsalgo.print_stats();
#endif    
    
    return elapsed;            
  }  

  template<typename RuntimeModelGen,
           typename EAGMConfig,
           typename LevelState>
  time_type execute_post_order_pf(const Graph& g,
                                  RuntimeModelGen rtmodelgen,
                                  EAGMConfig& config,
                                  WorkItem sw,
                                  LevelState vlevel,
                                  instance_params& runtime_params,
                                  agm_work_stats& sr, 
                                  bool _verify=true) {
    // Initial work item set
    typedef append_buffer<WorkItem, 10u> InitialWorkItems;
    InitialWorkItems initial;
    auto s = std::get<0>(sw);
    if (get(get(vertex_owner, g), s) == _RANK) {      
      initial.push_back(sw);
    }

    typedef bfs_pf<LevelState> ProcessingFunction;
    ProcessingFunction pf(g, vlevel, sr);

    // BFS algorithm
    typedef eagm<Graph,
                 WorkItem,
                 EMPTY_PF,
                 EAGMConfig,
                 RuntimeModelGen,
                 ProcessingFunction> bfs_eagm_t;

    bfs_eagm_t bfsalgo(rtmodelgen,
                       config,
                       pf,
                       initial);
    
    info("Invoking BFS algorithm with post-order processing function ...");
    time_type elapsed = bfsalgo(runtime_params);

#ifdef PBGL2_PRINT_WORK_STATS
    bfsalgo.print_stats();
#endif    
    
    return elapsed;            
  }  
  
  
public:
  template<typename RuntimeModelGen,
           typename EAGMConfig,
           typename agm_param_type>
  time_type execute_eagm(const Graph& g,
                         RuntimeModelGen rtmodelgen,
                         EAGMConfig& config,
                         agm_param_type& agm_params,
                         Vertex source,
                         instance_params& runtime_params,
                         agm_work_stats& sr, 
                         bool _verify=true) {

    info("Creating the state ...");
    // State
    typedef typename boost::property_map<Graph, boost::vertex_index_t>::type VertexIndexMap;
    std::vector<int> distmap(num_vertices(g), INT_MAX);
    typedef boost::iterator_property_map<typename std::vector<int>::iterator, VertexIndexMap> DistMap;
    DistMap distance_state(distmap.begin(), get(boost::vertex_index, g));

    // source
    WorkItem sw(source, 0);
    
    info("Invoking BFS algorithm ...");
    time_type elapsed = -1;

    if (agm_params.pf_mode == agm_pf_splitted) {
      elapsed = execute_split_pf(g,
                                 rtmodelgen,
                                 config,
                                 sw,
                                 distance_state,                                 
                                 runtime_params,
                                 sr,
                                 _verify);
    } else if (agm_params.pf_mode == agm_pf_preorder) {
      elapsed = execute_pre_order_pf(g,
                                     rtmodelgen,
                                     config,
                                     sw,
                                     distance_state,                                 
                                     runtime_params,
                                     sr,
                                     _verify);
      
    } else if (agm_params.pf_mode == agm_pf_postorder) {
      elapsed = execute_post_order_pf(g,
                                      rtmodelgen,
                                      config,
                                      sw,
                                      distance_state,                                 
                                      runtime_params,
                                      sr,
                                      _verify);
      
    } else {
      error("Invalid processing function invocation mode!");
      assert(false);
    }
    
    
    if (_verify) {
      verify(g, source, distance_state);
    }

    return elapsed;
  }
  
  template<typename RuntimeModelGen,
           typename StrictWeakOrdering>
  time_type execute(const Graph& g,
                    RuntimeModelGen rtmodelgen,
                    StrictWeakOrdering ordering,
		    instance_params& runtime_params,
		    agm_work_stats& sr, 
		    bool _verify=true) {

    info("Creating the state ...");
    // State
    typedef typename boost::property_map<Graph, boost::vertex_index_t>::type VertexIndexMap;
    std::vector<int> distmap(num_vertices(g), INT_MAX);
    typedef boost::iterator_property_map<typename std::vector<int>::iterator, VertexIndexMap> DistMap;
    DistMap distance_state(distmap.begin(), get(boost::vertex_index, g));

    // source
    Vertex source = 2;

    info("Setting the initial work item set ...");
    // Initial work item set
    std::vector<WorkItem> initial;
    initial.push_back(WorkItem(source, 0));

    info("Setting the processing function ...");
    // Processing funcion
    typedef bfs_pf<DistMap> ProcessingFunction;
    ProcessingFunction pf(g, distance_state, sr);
    
    // BFS algorithm
    typedef agm<Graph,
                WorkItem,
                ProcessingFunction,
                StrictWeakOrdering,
                RuntimeModelGen> bfs_agm_t;

    bfs_agm_t bfsalgo(pf,
                      ordering,
                      rtmodelgen);
    
    info("Invoking BFS algorithm ...");
    time_type elapsed = bfsalgo(initial, runtime_params);

    if (_verify) {
      verify(g, source, distance_state);
    }

    return elapsed;
  }
};

}}}
#endif
