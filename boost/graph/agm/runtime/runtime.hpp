// Copyright (C) 2018 Thejaka Amila Kanewala, Marcin Zalewski, Andrew Lumsdaine.

// Boost Software License - Version 1.0 - August 17th, 2003

// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:

// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//  Authors: Thejaka Kanewala
//           Andrew Lumsdaine

#ifndef __EAGM_RUNTIME_INTERFACE__
#define __EAGM_RUNTIME_INTERFACE__

#include <functional>
#include <atomic>

namespace boost { namespace graph { namespace agm {

template<typename work_item>
class runtime {

public:

  void send(const work_item& wi, int tid) = 0;

  void initialize_per_thread(int tid) = 0;
  
  void register_receiver(std::function<void(const work_item&, int)> funcrev) = 0;

  int find_numa_node(int tid) = 0;

  int get_nnuma_nodes() = 0;
  
  int get_nthreads() = 0;

  int get_nranks() = 0;

  void do_all_gather(void* _ptosend,
                     int sendcnt,
                     void* _precv,
                     int recvcnt) = 0;

  void increase_activity_count(int tid, uint64_t v) = 0;
  
  void decrease_activity_count(int tid, uint64_t v) = 0;

  uint64_t get_activity_count() = 0;
  
  int get_nthreads_for_numa_domain(int tid) = 0;

  int get_thread_index_in_numa_domain(int tid) = 0;

  void wait_for_numa_domain_threads_to_reach_here(int tid) = 0;

  bool is_main_thread_in_numa_domain(int tid) = 0;
  
  bool begin_epoch(int tid) = 0;
  
  bool is_epoch_completed(int tid) = 0;

  void end_epoch() = 0;

  unsigned long end_epoch_with_value(const unsigned long& _read_value) = 0;

  void pull_work(int tid) = 0;
  
  void synchronize() = 0;

  void wait_for_threads_to_reach_here(int tid) = 0;

  bool is_main_thread(int tid) = 0;
};


class runtime_base {
protected:
  int threads;
  int numa_domains;
  int ranks;  

public:
  runtime_base(int _threads, int _numa, int _ranks):threads(_threads),
                                                    numa_domains(_numa),
                                                    ranks(_ranks){}

  int get_nnuma_nodes() {
    return numa_domains;
  }
  
  inline int get_nthreads() {
    return threads;
  }  

  inline int get_nranks() {
    return ranks;
  }
};

}}}
#endif
